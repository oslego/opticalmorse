<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Optical Morse Code</title>
</head>
<body>
  <h1>Optical Morse Code + DeviceLight API</h1>

  <div id="output"></div>

  <script>

  (function(){

    var CHAR_TO_MORSE = {
      "A": ".-",
      "B": "-...",
      "C": "-.-.",
      "D": "-..",
      "E": ".",
      "F": "..-.",
      "G": "--.",
      "H": "....",
      "I": "..",
      "J": ".---",
      "K": "-.-",
      "L": ".-..",
      "M": "--",
      "N": "-.",
      "O": "---",
      "P": ".--.",
      "Q": "--.-",
      "R": ".-.",
      "S": "...",
      "T": "-",
      "U": "..-",
      "V": "...-",
      "W": ".--",
      "X": "-..-",
      "Y": "-.--",
      "Z": "--..",

      "1": ".----",
      "2": "..---",
      "3": "...--",
      "4": "....-",
      "5": ".....",
      "6": "-....",
      "7": "--...",
      "8": "---..",
      "9": "----.",
      "0": "-----"
    };

    // build reverse mapping Morse code to alpha-numeric
    var MORSE_TO_CHAR = {};
    for (var key in CHAR_TO_MORSE){
      MORSE_TO_CHAR[CHAR_TO_MORSE[key]] = key;
    }

    function OpticalServer(params) {
      params = params || {};

      this.wpm = params.wpm || 10;  // words per minute
      this.unit = 1200 / this.wpm; // duration of dot (milliseconds) in Morse Code

      this.callbacks = {};
      this.times = {
        // light
        dot: this.unit,
        dash: this.unit * 3,

        // dark
        break: this.unit,
        charBreak: this.unit * 3,
        wordBreak: this.unit * 7,
      }
      this.modes = {
        DARK: "dark",
        LIGHT: "light"
      }
      this.buffer = []; // temp array of morse code symbols as they are decoded
      this.mode; // current mode, one of "light" or "dark"
      this.isRunning = false; // flag for monitoring light variation as morse code
      this.lastTime; // UTC time (milliseconds) when mode last changed between "dark" and "light"
      this.lux = 0; // last known lux value from 'devicelight' event

      // TODO: run calibrarion considering normal room lux as dark
      this.luxThreshold = 1000; // min lux value considered as light signal
      this.wordBreakCount = 0; // count of consecutive workd breaks
      this.wordBreakCountLimit = 5 // number of consecutive word breaks after which to pause monitoring
      this.timeout;

      window.addEventListener('devicelight', this.onLightChange.bind(this));
    }

    /*
      Event handler for 'devicelight' event.
      Store the latest lux value of the light intensity.
      It the server isn't already running, start monitoring for optical morse code
      patterns if the lux value is above the threshold to qualify for a light pulse.
    */
    OpticalServer.prototype.onLightChange = function(e){
      this.lux = e.value;

      if (this.isRunning == false && this.lux >= this.luxThreshold){
        this.start();
        console.warn('start the server!')
      }
    };

    OpticalServer.prototype.on = function(event, callback) {
      if (event === "character"){
        this.callbacks.character = callback;
      }
    }

    OpticalServer.prototype.fire = function(callback, arg) {
      if (typeof(callback) === 'function') {
        callback(arg);
      }
    }

    OpticalServer.prototype.start = function() {
      this.isRunning = true;
      this.lastTime = Date.now();
      this.mode = this.modes.LIGHT;
      this.wordBreakCount = 0;
      this.buffer.length = 0;

      this.loop();
    }

    OpticalServer.prototype.stop = function() {
      console.warn('STOP');
      this.isRunning = false;
      this.timeout = clearTimeout(this.timeout);
    }

    OpticalServer.prototype.loop = function() {
      console.log('Looping:', this.lux);

      var modeNow = (this.lux >= this.luxThreshold) ? this.modes.LIGHT : this.modes.DARK;
      var duration;

      // TODO: add timeout for flushing elapsed time to decode()

      if (modeNow !== this.mode){

        console.log('MODE CHANGE: ', modeNow);

        duration = Date.now() - this.lastTime;

        this.decode(this.mode, duration);

        // Swap mode and set new time reference;
        this.mode = modeNow;
        this.lastTime = Date.now();

        this.timeout = clearTimeout(this.timeout);
      }

      if (this.isRunning && this.timeout === undefined){
        /*
          If mode stays unchanged for too long, flush the current buffer.
          Mode monitoring stops after a number of consecutive dark pauses (see: wordBreakCountLimit)
        */
        this.timeout = setTimeout(function(){
          var duration = Date.now() - this.lastTime;
          console.log('TIME ELAPSED:', this.mode, duration);

          this.decode(this.mode, duration);
          this.lastTime = Date.now();
          this.timeout = clearTimeout(this.timeout);
        }.bind(this), this.times.wordBreak * 2);
      }

      if (this.isRunning){
        _raf(this.loop.bind(this))
      }
    }

    OpticalServer.prototype.decode = function(mode, duration) {
      var op; // placeholder for operation to run according to mode and duration

      switch (mode){
        case this.modes.DARK:
          // break within character
          if (duration >= this.times.break * 0.5) {
            op = function() {
              this.buffer.push('');
              // used for testing
              return "OP_BREAK";
            }
          }

          // break between characters
          if (duration >= this.times.charBreak * 0.5) {
            op = function(){

              var char = this.morseToChar(this.buffer.join(''));

              if (!char) {
                console.error('Unknown character for code:', this.buffer.join(''));
              } else {
                this.fire(this.callbacks.character, char);

                // reset consecutive word break count
                this.wordBreakCount = 0;
              }

              // reset morse code symbols buffer;
              this.buffer.length = 0;

              // used for testing
              return "OP_CHAR_BREAK"
            }
          }

          // break between words
          if (duration >= this.times.wordBreak * 0.75) {
            op = function(){
              // increment consecutive word break count;
              this.wordBreakCount++;

              console.warn(this.wordBreakCount, 'buffer: ', this.buffer.join(''))

              if (this.buffer.length){
                var char = this.morseToChar(this.buffer.join(''));

                if (!char) {
                  console.error('Unknown character for code:', this.buffer.join(''));
                } else {
                  // include space after last char of word
                  char = char + " ";
                  this.fire(this.callbacks.character, char);
                  this.wordBreakCount = 0;
                }

                this.buffer.length = 0;
              }

              if (this.wordBreakCount >= this.wordBreakCountLimit) {
                this.stop();
              }

              // used for testing
              return "OP_WORD_BREAK"
            }
          }
        break;

        // be more leninent with checking light durations
        case this.modes.LIGHT:
          // fallback
          op = function(){ console.warn('noop') }

          if (duration <= this.times.dot * 1.25) {
            op = function() {
              this.buffer.push('.');

              return "OP_DOT";
            }
          }

          if (duration >= this.times.dash * 0.75) {
            op = function() {
              this.buffer.push('-');

              return "OP_DASH";
            }
          }
        break;
      }

      // run prevailing operation; returns string value for testing
      return op.call(this);
    }

    OpticalServer.prototype.charToMorse = function(char) {
      return CHAR_TO_MORSE[char];
    }

    OpticalServer.prototype.morseToChar = function(morse) {
      return MORSE_TO_CHAR[morse];
    }

    /**
     * A request animation frame shortcut. This one is intended to work even in
     * background pages of an extension.
     */
    function _raf(callback) {
      var isCrx = !!(window.chrome && chrome.extension);
      if (isCrx) {
        setTimeout(callback, 1000/60);
      } else {
        requestAnimationFrame(callback);
      }
    };

    // expose global
    window.OpticalServer = OpticalServer;

  })()

  server = new OpticalServer();
  server.on('character', function(char){
    document.querySelector('#output').textContent += char;
    console.info('Incoming: ', char)
  })

  function emit(arr){
    if (!arr.length){
      return;
    }

    function dispatchLightEvent(value){
      var mock = new DeviceLightEvent('devicelight', { value: value });
      window.dispatchEvent(mock);
    }

    var interval, timeout;


    var char = arr.shift();
    var duration;
    var lux;

    if (char == '.'){
      lux = 1000;
      duration = server.times.dot;
    }

    if (char == '-'){
      lux = 1000;
      duration = server.times.dash;
    }

    if (char == ' '){
      lux = 50;
      duration = server.times.break;
    }

    if (char == '|'){
      lux = 50;
      duration = server.times.charBreak;
    }

    if (char == '/'){
      lux = 50;
      duration = server.times.wordBreak;
    }

    interval = setInterval(function(){ dispatchLightEvent(lux) }, 20);
    timeout = setTimeout(function(){
      interval = clearInterval(interval);
      timeout = clearTimeout(timeout);
      // continue emitting
      emit(arr)
    }, duration);
  }

  emit('.|. -/. '.split(''))

  // TESTING -----------------------------------

  // console.group('testing')
  //
  // // CONVERTORS
  // console.assert("A"  == server.morseToChar('.-'), "Morse to Char");
  // console.assert(".-" == server.charToMorse('A'), "Char to Morse");
  //
  // // DARK
  // console.assert("OP_BREAK"      == server.decode(server.modes.DARK, server.times.break), "OP_BREAK");
  // server.buffer.push('.-'); // A
  // console.assert("OP_CHAR_BREAK" == server.decode(server.modes.DARK, server.times.charBreak), "OP_CHAR_BREAK");
  // server.buffer.push('.-'); // A
  // console.assert("OP_WORD_BREAK" == server.decode(server.modes.DARK, server.times.wordBreak), "OP_WORD_BREAK");
  //
  // // LIGHT
  // server.buffer.length = 0;
  // console.assert("OP_DOT"  == server.decode(server.modes.LIGHT, server.times.dot), "OP_DOT");
  // console.assert("."  == server.buffer.join(''), "BUFFER_DOT");
  // console.assert("OP_DOT"  == server.decode(server.modes.LIGHT, server.times.dot * 0.75), "OP_DOT lenient");
  // console.assert(".."  == server.buffer.join(''), "BUFFER_DOT_DOUBLE");
  //
  // server.buffer.length = 0;
  // console.assert("OP_DASH"  == server.decode(server.modes.LIGHT, server.times.dash), "OP_DASH");
  // console.assert("-"  == server.buffer.join(''), "BUFFER_DASH");
  // console.assert("OP_DASH"  == server.decode(server.modes.LIGHT, server.times.dash * 0.75), "OP_DASH lenient");
  // console.assert("--"  == server.buffer.join(''), "BUFFER_DASH_DOUBLE");
  //
  // console.groupEnd('')

  </script>
</body>
</html>
